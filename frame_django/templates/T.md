#### 模板语句（Template）
Django的设计哲学理念：业务逻辑应该和表现逻辑相对分开。

    + 将模板系统视为控制表现及表现相关逻辑的工具，不应提供超出此基本目标的功能。
    + 在模板中不能直接调用 Python 代码。
    + 语法不应受到 HTML/XML 的束缚。

1. {{ var }}，变量(variable)如果一个变量不存在，模板系统会把它展示为空字符串，不做任何事情来表示失败。

2. {% if ordered_warranty %}...[{% else %}]....{% endif %}，模板标签(template tag)
    + 接受 and、or或者not、and not关键字来对多个变量做判断、取反;
    + 不允许在同一个标签中同时使用and和or;
    + 不支持用()来组合比较操作。
    + 没有{% elif %}标签，可以使用嵌套的`` {% if %}``标签来达成同样的效果；
    + 一定要用 {% endif %} 关闭每一个 {% if %} 标签。

3. {% for item in item_list [reversed] %}...{% end for%}，模板标签(template tag)
    + reversed，使列表被反向迭代；
    + 可以嵌套使用 {% for %} 标签；
    + 通常在执行循环之前先检测列表的大小，当列表为空时输出一些特别的提示；
    + 支持一个可选的`` {% empty %}``分句，定义当列表为空时的输出内容；
    + 不支持退出循环操作。如果想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目；
    + 不支持continue语句；
    + 在每个`` {% for %}``循环里有一个`` forloop``模板变量。这个变量有一些提示循环进度信息的属性。
        + forloop.counter 总是一个表示当前循环的执行次数的整数计数器。这个计数器是从1开始的，所以在第一次循环时forloop.counter将会被设置为1；
        + forloop.counter0类似于 forloop.counter，但是它是从0计数的。第一次执行循环时这个变量会被设置为0；
        + forloop.revcounter是表示循环中剩余项的整型变量。在循环初次执行时forloop.revcounter将被设置为序列中项的总数。最后一次循环执行中，这个变量将被置1；
        + forloop.revcounter0类似于forloop.revcounter，但它以0做为结束索引。在第一次执行循环时，该变量会被置为序列的项的个数减1；
        + forloop.first是一个布尔值，如果该迭代是第一次执行，那么它被置为True；
        + forloop.last 是一个布尔值；在最后一次执行循环时被置为True，一个常见的用法是在一系列的链接之间放置管道符（|）或逗号；
        + forloop 变量仅仅能够在循环中使用。 在模板解析器碰到{% endfor %}标签后，forloop就不可访问了；
        + 一旦我们在Context中定义了 forloop 这个变量（反对这样做），在 {% for %} 块中它会被重新命名为 forloop.parentloop。

4. {% ifequal/ifnotequal %}...[{% else%}]...{% endifequal %}，模板标签(template tag)
只有模板变量，字符串，整数和小数可以作为 {% ifequal %} 标签的参数，其他任何类型，例如Python的字典类型、列表类型、布尔类型，不能用在 {% ifequal %} 中。

5. {# #}，Django模板语言代码注释。

6. {{...|...}}，过滤器，在变量被显示前修改它的值的一个简单方法。
    + 过滤器使用管道字符。
    + 过滤管道可以被套接————一个过滤器管道的输出又可以作为下一个管道的输入，如此下去。
    + 有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。
    + addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。这在处理包含JavaScript文本时非常有用。
    + length : 返回变量（有__len__()方法的对象）的长度。
    + first、upper、lower...

7. 模板语句中，变量加一点(dots)可以访问它的属性，可以用来引用对象的方法，可用于访问列表索引（不允许使用负索引）。句点查找可以多级深度嵌套。  

假如，一个 BankAccount 对象有一个 delete() 方法。如果某个模板中包含了像 {{ account.delete }}这样的标签，其中`` account``是BankAccount的一个实例，在这个模板载入时，account对象将被删除。  
要防止这样的事情发生，必须设置该方法的 alters_data 函数属性：  
`def delete(self):
    # Delete the account
delete.alters_data = True`  
那么在模板载入时， delete()方法将不会被执行。 它将静静地错误退出。  

8.  {% include ... %} 
    + 该标签允许在（模板中）包含其它的模板的内容，减少重复。  
    + 标签的参数是所要包含的模板名称，可以是一个变量，也可以是用单/双引号硬编码的字符串。
    + 如果{% include ... %}标签指定的模板没找到：
        * 如果DEBUG设置为True，错误信息页面显示 TemplateDoesNotExist 异常。
        * 如果DEBUG设置为False，该标签不会引发错误信息，在标签位置不显示任何东西。 

9. {% block ... %}...{% endblock %}  
    + 子模板可以重载所有{% block %} 标签下的内容。
    + 在子模板中使用 {% extends... %} 进行继承，必须保证其为模板中的第一个模板标记。否则，模板继承将不起作用。
    + 一般来说，基础模板中的 {% block ... %} 标签越多越好。子模板不必定义父模板中所有的代码块，可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。

10. {{ block.super }}，不仅仅是覆盖父模板，还可以在父模板基础上追加内容。在上级代码块基础上添加内容，而不是全部重载。 
