######使用索引的缺点
- 减慢增删改数据的速度；
- 占用磁盘空间；
- 增加查询优化器的负担；

当查询优化器生成执行计划时，会考虑索引，太多的索引会给查询优化器增加工作量，导致无法选择最优的查询。
分析索引效率。

######EXPLAIN
在一般的SQL语句前加上EXPLAIN，可以帮助选择更好的索引和写出更优化的查询语句。

分析结果的含义：

|      字段     |                          含义                          |
|---------------|--------------------------------------------------------|
| id            | SELECT识别符————SELECT查询序列号                       |
| select_type   | select类型                                             |
|               | simple————简单的select，没有union和子查询              |
|               | primary————在有子查询的语句中，最外面的select          |
|               | union————UNION语句后面的SELECT                         |
|               | dependent union————UNION后面的SELECT，取决于外面的查询 |
|               | union result————UNION的结果                            |
| table         | 表名                                                   |
| type          | 连接的类型(ALL/Range/Ref)，其中ref是最理想的           |
| system        | const类型的特列，平时不会出现                          |
| possible_keys | 查询可以利用的索引名                                   |
| key           | 实际使用的索引                                         |
| key_len       | 索引中被使用部分的长度（字节）                         |
| ref           | 显示列名字或者"const"                                  |
|               | const用于只检索出两条数据的情况下，                    |
|               | 比较primary key 或者unique索引                         |
| rows          | 显示MySQL认为在找到正确结果之前必须扫描的行数          |
| extra         | MySQL的建议                                            |
　　
######优化查询
- 尽可能使用较短的数据类型；
- 尽可能使用定长数据类型（用char代替varchar）；万一出现数据表崩溃，使用固定长度数据行的表更容易重新构造。使用固定长度的数据行，每个记录的开始位置都是固定记录长度的倍数，可以很容易被检测到，但是使用可变长度的数据行就不一定了（对于MyISAM类型的数据表，虽然转换成固定长度的数据列可以提高性能，但是占据的空间也大）；
- 尽量将列定义为not null，这样在查询时，MySQL不需要检查是否存在特例，即null值，从而优化查询；而且所需的空间更少；
- 如果一列只含有有限数目的特定值，如性别、是否有效或者入学年份等，在这种情况下应该考虑将其转换为enum列的值，MySQL处理的更快，因为所有的enum值在系统内都是以标识数值来表示的；
- 使用optimize table对于经常修改的表，容易产生碎片，使在查询数据库时必须读取更多的磁盘块，降低查询性能。具有可变长的表都存在磁盘碎片问题，这个问题对blob数据类型更为突出，因为其尺寸变化非常大。可以通过使用optimize table来整理碎片，保证数据库性能不下降，优化那些受碎片影响的数据表。 optimize table可以用于MyISAM和BDB类型的数据表。实际上任何碎片整理方法都是用mysqldump来转存数据表，然后使用转存后的文件并重新建数据表；

（六）使用procedure analyse()显示最佳类型的建议，使用很简单，在select语句后面加上procedure analyse()就可以了；例如：
　　select * from students procedure analyse();
　　select * from students procedure analyse(16,256);
第二条语句要求procedure analyse()建议不要含有少于16个值，或者含有多于256字节的enum类型，如果没有限制，输出可能会很长；

（七）使用查询缓存
	1）查询缓存的工作方式：
第一次执行某条select语句时，服务器记住该查询的文本内容和查询结果，存储在缓存中，下次碰到这个语句时，直接从缓存中返回结果；当更新数据表后，该数据表的任何缓存查询都变成无效的，并且会被丢弃。
	2）配置缓存参数：
变量：query_cache _type，查询缓存的操作模式。有3中模式，0：不缓存；1：缓存查询，除非与 select sql_no_cache开头；2：根据需要只缓存那些以select sql_cache开头的查询； query_cache_size：设置查询缓存的最大结果集的大小，比这个值大的不会被缓存。
	3）调整硬件
		在机器上装更多的内存；
		增加更快的硬盘以减少I/O等待时间；
寻道时间是决定性能的主要因素，逐字地移动磁头是最慢的，一旦磁头定位，从磁道读则很快；
		在不同的物理硬盘设备上重新分配磁盘活动；
如果可能，应将最繁忙的数据库存放在不同的物理设备上，这跟使用同一物理设备的不同分区是不同的，因为它们将争用相同的物理资源（磁头）。


永远用小结果集驱动大结果集

当不确定是用哪种类型的join时，让mysql优化器自动去判断。