####设置urls
Django和URL配置背后的哲学：松耦合原则。简单的说，松耦合是一个重要的保证互换性的软件开发方法。决定URL返回哪个视图函数和实现这个视图函数是在两个不同的地方。这使得开发人员可以修改一块而不会影响另一块。  
正则表达式字符串的开头字母“r”。它告诉Python这是个原始字符串，不需要处理里面的反斜杠（转义字符）。  
根目录的URL模式："^$"，它代表一个空字符串。  
Django在URLconf中的所有URL模式中，查找第一个匹配【请求路径字符】的URLpatterns。如果找到匹配，将调用相应的view函数，并把 HttpRequest 对象作为第一个参数。  
请求路径字符的捕获值永远都是字符串（string）类型，并且是Unicode objects，而不会是整数（integer）类型，即使这个字符串全由数字构成（如：“21”）。 

    from mysite.views import hello  
    urlpatterns = patterns('',  
    　　(r'^hello/$', hello),
    )
    或者
    from mysite.views import views  
    urlpatterns = patterns('',  
    　　(r'^hello/$', views.hello),
    )
    或者
    urlpatterns = patterns('',  
    　　(r'^hello/$', 'you_proj.views.hello'),#注意引号
    )
    或者
    urlpatterns = patterns('mysite.views' ,
        (r'^hello/$', 'hello'),
    )


    使用多个视图前缀
    urlpatterns += patterns('weblog.views',
        (r'^tag/(\w+)/$', 'tag'),
    )


    调试模式中的特例————只在 DEBUG 配置项设为 True 时才有效
    if settings.DEBUG:
        urlpatterns += patterns('',
            (r'^debuginfo/$', views.debug),
        )


    使用命名组，传递关键字参数
    urlpatterns = patterns('',
        (r'^articles/(?P<year>\d{4})/(?P<month>\d{2})/$', views.month_archive),
    )
    #views
    def month_archive(request, year='2006', month='03'):
        ...
    默认参数值是字符串，不是整数。这是为了保持一致，因为捕捉的值总是字符串。
如果在URLconf中使用命名组，那么命名组和非命名组是不能同时存在于同一个URLconf的模式中的。如果你这样做，Django不会抛出任何错误，但你可能会发现你的URL并没有像你预想的那样匹配正确。具体地，以下是URLconf解释器有关正则表达式中命名组和 非命名组所遵循的算法:  

- 如果有任何命名的组，Django会忽略非命名组而直接使用命名组。
- 否则，Django会把所有非命名组以位置参数的形式传递。
- 在以上的两种情况，Django同时会以关键字参数的方式传递一些额外参数。

---

    传递额外的参数到视图函数中
    urlpatterns = patterns('',
        (r'^foo/$', views.foobar_view, {'template_name': 'template1.html'}),
        (r'^bar/$', views.foobar_view, {'template_name': 'template2.html'}),
    )
    # views.py  
    def foobar_view(request, template_name):
        m_list = MyModel.objects.filter(is_new=True)
        return render_to_response(template_name, {'m_list': m_list})


    伪造捕捉到的URLconf值
    (r'^mydata/birthday/$', views.my_view, {'month': 'jan', 'day': '06'}),
    /mydata/birthday/ ， 这个URL等价于 /mydata/jan/06/。


    抽取出代码中共性的东西，共用一个视图函数
    urlpatterns = patterns('',
        (r'^events/$', views.object_list, {'model': models.Event}),
        (r'^blog/entries/$', views.object_list, {'model': models.BlogEntry}),
    )
    # views.py
    def object_list(request, model):
        obj_list = model.objects.all()
        template_name = 'mysite/%s_list.html' % model.__name__.lower()#每个Python的类都有一个 __name__ 属性返回类名。 
        return render_to_response(template_name, {'object_list': obj_list})


    硬编码的（额外字典的） id 将优先使用。就是说任何请求（比如， /mydata/2/ 或者 /mydata/432432/ ），不管URL里面能捕捉到什么样的值，都会把id作为3对待。  
    urlpatterns = patterns('',
        (r'^mydata/(?P<id>\d+)/$', views.my_view, {'id': 3}),
    )

    
    urlpatterns = patterns('',
        # ...
        ('^auth/user/add/$', views.user_add_stage),
        ('^([^/]+)/([^/]+)/add/$', views.add_stage),
        # ...
    )
    利用URLconf从顶向下的解析顺序这个特点，优先处理/auth/user/add/这个特殊情况。
    然后处理在URLconf中的一系列URL。


    在解析URLconf时，请求方法（例如， POST ， GET ， HEAD ）不会被考虑。换而言之，对于相同的URL的所有请求方法将被导向到相同的函数中。因此根据请求方法来处理分支是视图函数的责任。
    #urls
    urlpatterns = patterns('',
        # ...
        (r'^somepage/$', views.some_page),
        # ...
    ) 
    #views
    def some_page(request):
        if request.method == 'POST':
            do_something_for_post()
            return HttpResponseRedirect('/someurl/')
        elif request.method == 'GET':
            do_something_for_get()
            return render_to_response('page.html')
        else:
            raise Http404()
    或者
    #urls
    urlpatterns = patterns('',
        # ...
        (r'^somepage/$', views.method_splitter, 
        {'GET': views.some_page_get, 'POST': views.some_page_post}),
        # ...
    )
    #views
    def method_splitter(request, GET=None, POST=None):
        if request.method == 'GET'[ and GET is not None]:
            ...
            return GET(request)
        if request.method == 'POST'[ and POST is not None]:
            ...
            return POST(request)
        else:
            ...
            raise Http404
    def some_page_get(request):
        assert request.method == 'GET'
        ...
    def some_page_get(request):
        assert request.method == 'POST'
        ...

    def method_splitter(request, *args, **kwargs):
        get_view = kwargs.pop('GET', None)
        post_view = kwargs.pop('POST', None)
        if request.method == 'GET' and get_view is not None:
            return get_view(request, *args, **kwargs)
        elif request.method == 'POST' and post_view is not None:
            return post_view(request, *args, **kwargs)
        raise Http404


    def requires_login(view):
        def new_view(request, *args, **kwargs):
            if not request.user.is_authenticated():
                return HttpResponseRedirect('/accounts/login/')
            return view(request, *args, **kwargs)
        return new_view
    urlpatterns = patterns('',
        (r'^view1/$', requires_login(my_view1)),
        (r'^view2/$', requires_login(my_view2)),
        (r'^view3/$', requires_login(my_view3)),
    )
    is_authenticated()，检查request.user是否是已经认证的，是的话，当前用户已经成功登陆站点否则就重定向/accounts/login/。
    函数requires_login,传入一个视图函数view，然后返回一个新的视图函数new_view。这个新的视图函数new_view在函数requires_login内定义处理request.user.is_authenticated()这个验证，从而决定是否执行原来的view函数。
    我们可以在URLconf中很容易的用requires_login来包装实现。


    包含其他URLconf
    URLconf都可以包含其他URLconf模块，从而让代码用在多个基于Django的站点上。
    from django.conf.urls.defaults import *
    urlpatterns = patterns('',
        (r'^weblog/', include('mysite.blog.urls'), {'blogid': 3}),
        (r'^photos/', include('mysite.photos.urls')),
        (r'^about/$', 'mysite.views.about'),
    )
    指向 include()的正则表达式不包含$（字符串结尾匹配符），但是包含了一个斜杆。每当Django遇到include()时，它将截断匹配的URL，并把剩余的字符串发往包含的URLconf作进一步处理。
    额外的选项————{'blogid': 3}将总是被传递到被包含的URLconf————mysite.blog.urls中的每一行。

