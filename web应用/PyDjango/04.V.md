#### V，设置views
每一个视图总是以一个 HttpRequest 对象作为它的第一个参数。通常被叫做request，这是一个触发这个视图、包含当前Web请求信息的对象，是类django.http.HttpRequest的一个实例。  
一个视图功能必须返回一个HttpResponse实例。一旦做完，Django将完成剩余的转换Python的对象到一个合适的带有HTTP头和body的Web Response。  

from django.template import Template, Context  
from django.template.loader import get_template  
from django.http import HttpResponse  
from django.shortcuts import render_to_response    

return返回对象：

1. HttpResponse
    + return HttpResponse(str_obj)

2. render
    + 创建 Template 对象：
        * tem = template.Template('My name is {{ name }}.')
        * tem = get_template('.../.../***.html')
    + 创建上下文对象：
        * c = Context({'name': 'Adrian', ...})
    + 返回响应对象：
        * return tem.render(c)
        * return tem.render(Context({...}))  
    **返回的值是一个Unicode对象。在框架中，Django会一直使用Unicode对象而不是普通的字符串。**

Context 是一个传递给模板的名称到值的映射（类似Python字典）。模板渲染就是通过从Context获取值来替换模板中变量并执行所有的模板标签。
    
    当你渲染模板时，你要用 RequestContext 而不是 Context 。
    from django.template import loader, RequestContext
    def custom_proc(request):
        "A context processor that provides 'app', 'user' and 'ip_address'."
        return {
            'app': 'My app',
            'user': request.user,
            'ip_address': request.META['REMOTE_ADDR']
        }#定义一个函数 custom_proc，这是一个context处理器，它接收一个 HttpRequest对象，然后返回一个字典，这个字典中包含了可以在模板Context中使用的公共变量。
    def view_1(request):
        # ...
        t = loader.get_template('template1.html')
        c = RequestContext(request, {'message': 'I am view 1.'},
                processors=[custom_proc])
        return t.render(c)
    def view_2(request):
        # ...
        return render_to_response(
            'template2.html',
            {'message': 'I am the second view.'},
            context_instance=RequestContext(request, processors=[custom_proc]))

Django提供对全局 context 处理器的支持。
TEMPLATE_CONTEXT_PROCESSORS指定了哪些context processors总是默认被使用。
这样就省去了每次使用 RequestContext 都指定 processors 的麻烦。
默认情况下， settings的TEMPLATE_CONTEXT_PROCESSORS 设置如下：  

    TEMPLATE_CONTEXT_PROCESSORS = (
        'django.core.context_processors.auth',
        'django.core.context_processors.debug',
        'django.core.context_processors.i18n',
        'django.core.context_processors.media',
    )

3. HttpResponseRedirect(url_str)————重定向

4. render_to_response，是对get_template()的简单封装
    + render_to_response('***.html'[,dict_obj])
    + render_to_response('.../.../htmlFile',contextDict)；
    + 可以用local()替代contextDict以及其它局部变量，返回一个包含当前作用域里面的所有变量和它们的值的字典；



在你视图的任何位置，临时插入一个 assert False 来触发出错页。然后，你就可以看到局部变量和程序语句了。Django 出错信息仅在 debug 模式下才会显现。  
 
*SELECT `*`比列出所有字段慢，而且最重要的是列出所有字段遵循了Python的一个信条：明言胜于暗示。*  

- mcj.objects.all()，返回对应models中所有项的数据库查询结果（QuerySet，看起来像list格式）；
- mcj.columnName，取表中某列值；
- mcj.objects.filter(columnName='`***`')，数据过滤（where sql）;
    + 可以传递多个参数；
    + columnName__contains='`***`'，相当于columnName like '`***`'；
    + columnName__icontains，忽略大小写的like；
    + startswith和endswith，还有range(BETWEEN查询）。
- mcj.objects.get(columnName=product_id)，获取单个对象（可能异常：DoesNotExist）；
- mcj.objects.order_by('`***`')，以任意字段进行排序；
    + 字段可以多个；
    + 可以指定逆向排序，在字段字符前面加一个 '-' 前缀，相当于desc；
    + class Meta:  
        ordering = ['name']，指定缺省排序；
- mcj.objects.all()[0]，限制返回的数据，相当于limit 1。
    + mcj.objects.all()[1:3]，相当于OFFSET 1 LIMIT 2。
    + 不支持负索引。
- 可以使用以上方法连锁查询。

- mcj.objects.create(键值对)，创建对象并存储至数据库；
- mcj.save()，更新表；
- mcj.objects.filter(columnName='`***`').update(columnName='`***`')，精确更新，返回一个整型数值，表示受影响的记录条数；

- mcj.objects.get(columnName='`***`').delete()，删除数据；
    + mcj.objects.all().delete()，为了预防误删除掉某一个表内的所有数据，Django要求在删除表内所有数据时显示使用all()；

#####Django时区
django中获取当前时间不要用datetime.today()，要用timezone.now()
from django.utils import timezone
print timezone.localtime(thetime)    thetime即为需要转换的时间
Django的默认时区为America/Chicago。（Django诞生地：美国/芝加哥），如果你处在别的时区，你需要在settings.py文件中更改这个值。请参见它里面的注释，以获得最新世界时区列表。   
